---
title: "F2 simulations results"
date: "`r Sys.Date()`"
author: "[Statistical Genetics Lab](http://statgen.esalq.usp.br) <br/> Department of Genetics <br/> Luiz de Queiroz College of Agriculture <br/> University of São Paulo"
output:
rmdformats::readthedown:
css: readthedownstatgen.css
code_folding: hide
---

```{r knitr_init, echo=FALSE, cache=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")

opts_knit$set(width=75)
```

This report include analysis with all output files generated by the simulations workflow for F2 populations.

## Output files

Short description about the output files.

From CreatePedigreeSimulatorInputs task:

* mapfile.map

marker chromosome position(cM)

* tot_mks.txt

chr pos ref alt 

From CalculateVcfMetrics task:

* method_alt_depth.txt

method = c("gatk", "freebayes", "stacks")

columns = individuals
lines = markers
cells = counts for alternative alleles

* method_ref_depth.txt

method = c("gatk", "freebayes", "stacks")

columns = individuals
lines = markers
cells = counts for reference alleles

* method_GQ.txt

Ta com pau.. arrumar!

* method.txt
nmk.filt nmk.id ok falso.positivo ref.ok alt.ok

nmk.filt - How many SNPs should have considering the RAD fragments
nmk.id - How many SNPS were identified in vcf
ok - How many SNPs in vcf are in correct position
falso.positivo - How many do not
ref.ok - Correct reference alleles
alt.ok - Correct alternative alleles

From all_maps task:

* method_error_info_genotypeMethod.txt

method = c("gatk", "freebayes", "stacks")
genotypeMethod = c("GQ", "polyrad", "supermassa", "updog")

MK POS gabGT methGT 1 2 3 4 5

* method_filters_genotypeMethod.txt

method = c("gatk", "freebayes", "stacks")
genotypeMethod = c("dfAndGQ", "polyrad", "supermassa", "updog")

n_markers distorted_markers redundant_markers

* method_map_genotypeMethod.txt

method = c("gatk", "freebayes", "stacks")
genotypeMethod = c("df", "GQ", "polyrad", "supermassa", "updog")

MK POS cM


# Path

**The only part of this report that you need to change**

```{r, warning=FALSE, message=FALSE, results='hide'}
path <- "~/github/errors_workflow/cromwell-executions/reads_simu/ffe52f45-ee46-46f7-b483-28e892cda582"
cMByMb <- 4.63
depth.ex <- 20
```


# Packages

```{r, warning=FALSE, message=FALSE, results='hide'}
library(ggplot2)
library(reshape2)
library(vcfR)
```

# Code for only one family - pilot

```{r, warning=FALSE, message=FALSE, results='hide'}
setwd(path)
method <- c("gatk", "freebayes")
meth.bam <-  c("polyrad", "updog", "supermassa")
meth.geno <- c("df", "GQ", "polyrad", "updog", "supermassa")

mapfile <- read.table("call-CreatePedigreeSimulatorInputs/execution/mapfile.txt", header=T)

tot_mks <- read.table("call-CreatePedigreeSimulatorInputs/execution/tot_mks.txt")
id <- c(0,1)
p  <- p.bam  <- list()

df.diff.dis <- as.list(rep(NA, length(method)))
for(i in 1:length(df.diff.dis)){
  df.diff.dis[[i]] <- as.list(rep(NA, length(meth.geno)))
}

df.diff.dis.bam <- as.list(rep(NA, length(method)))
for(i in 1:length(df.diff.dis.bam)){
  df.diff.dis.bam[[i]] <- as.list(rep(NA, length(meth.bam)))
}



df.per.geno <- df.coverage <- df.diff.tot <- df.diff.median <- df.diff.mean <- names.id <- df.filt <- vector()
df.per.geno.bam <- df.coverage.bam <- df.diff.tot.bam <- df.diff.median.bam <- df.diff.mean.bam <- vector()


for(i in 1:length(method)){
  ## vcfs
  vcf <- read.vcfR(paste0("call-VcftoolsApplyFilters/execution/",method[i], ".recode.vcf"))
  gt <- vcf@gt[,-1]
  gt <- gt[,sort(colnames(gt))]
  gt <- melt(gt)
  gt$value <- sapply(strsplit(as.character(gt$value), ":"), "[", 1)
  
  # Filters
  filt <- read.table(paste0("call-CalculateVcfMetrics/execution/",method[i], ".txt"), header = T)
  df.filt <- rbind(df.filt, filt)
  
  ## Depths by bam
  alt_depth <- read.table(paste0("call-BamCounts4Onemap/execution/", method[i], "_alt_depth_bam.txt"), header = T, stringsAsFactors = F)
  alt_depth <- as.data.frame(apply(alt_depth, 2, as.integer))
  alt_depth <- alt_depth[,sort(colnames(alt_depth))]
  alt <- melt(alt_depth)
  
  ref_depth <- read.table(paste0("call-BamCounts4Onemap/execution/", method[i], "_ref_depth_bam.txt"), header = T, stringsAsFactors = F)
  ref_depth <- as.data.frame(apply(ref_depth, 2, as.integer))
  ref_depth <- ref_depth[,sort(colnames(ref_depth))]
  ref <- melt(ref_depth)
  
  idx.id <- match(gt$Var2, ref$variable)
  df.depths <- data.frame(ind = ref$variable, alt = alt$value, ref=ref$value)
  
  p.bam[[i]] <- ggplot(df.depths, aes(x=ref, y=alt)) + geom_point(size=0.5) +
    labs(title= paste0(method[i]," depths example"),x="ref", y = "alt") + xlim(0,depth.ex) + ylim(0,depth.ex)
  
  ## Depths by softwares
  alt_depth <- read.table(paste0("call-CalculateVcfMetrics/execution/", method[i], "_alt_depth.txt"), header = T, stringsAsFactors = F)
  alt_depth <- as.data.frame(apply(alt_depth, 2, as.integer))
  alt_depth <- alt_depth[,sort(colnames(alt_depth))]
  alt <- melt(alt_depth)
  
  ref_depth <- read.table(paste0("call-CalculateVcfMetrics/execution/", method[i], "_ref_depth.txt"), header = T, stringsAsFactors = F)
  ref_depth <- as.data.frame(apply(ref_depth, 2, as.integer))
  ref_depth <- ref_depth[,sort(colnames(ref_depth))]
  ref <- melt(ref_depth)
  df.depths <- data.frame(ind = gt$Var2, gt = gt$value, alt = alt$value, ref=ref$value)
  
  p[[i]] <- ggplot(df.depths, aes(x=ref, y=alt, color=as.factor(gt))) + geom_point(size=0.5) +
    labs(title= paste0(method[i]," depths example"),x="ref", y = "alt", color="Genotypes") + xlim(0,depth.ex) + ylim(0,depth.ex)
  
  for(j in 1:length(meth.geno)){
    # Map distance
    maps <- read.table(paste0("call-all_maps/shard-", id[i],"/execution/", method[i],"_map_", meth.geno[j],".txt"), header =T)
    
    poscM <- (as.numeric(as.character(maps[,2]))/1000000)*cMByMb
    poscM.norm <- poscM-poscM[1]
    maps <- cbind(maps, poscM, poscM.norm)
    
    # Difference between distances real and estimated
    diff.dis <- sqrt((maps$poscM.norm - maps$rf)^2)
    df.diff.dis[[i]][[j]] <- diff.dis
    names(df.diff.dis[[i]][[j]]) <- paste0(method[i],"_",meth.geno[j])
    
    # Meth names
    names.id <-  c(names.id,paste0(method[i],"_",meth.geno[j]))
    
    # Mean of differences
    diff.dis.mean <- mean(sqrt((maps$poscM.norm - maps$rf)^2))
    df.diff.mean <- c(df.diff.mean,diff.dis.mean)
    
    
    # Median of differences
    diff.dis.median <- median(sqrt((maps$poscM.norm - maps$rf)^2))
    df.diff.median <- c(df.diff.median,diff.dis.median)
    
    # Difference of total size
    diff.tot.dis <- sqrt((maps$poscM.norm[length(maps$poscM.norm)] - maps$rf[length(maps$rf)])^2)
    df.diff.tot <- c(df.diff.tot,diff.tot.dis)
    
    mapfile.pos <- cbind(mapfile, tot_mks[,2])
    
    # Percentage of the chromosome covered 
    coverage <- maps$pos[length(maps$pos)]*100/mapfile.pos[,4][length(mapfile.pos[,4])]
    df.coverage <- c(df.coverage,coverage)
    
    # Percentage of rigth genotyping
    if(meth.geno[j] != "df"){
      per.geno <- read.table(paste0("call-all_maps/shard-",id[i],"/execution/",method[i],"_error_",meth.geno[j],".txt"), header =T)
      per.geno <- (sum(per.geno$gabGT == per.geno$methGT)/length(per.geno$methGT)*100)
      df.per.geno <- c(df.per.geno,per.geno)
    }
  }
  
  for(j in 1:length(meth.bam)){
    # Map distance
    maps <- read.table(paste0("call-all_maps/shard-", id[i],"/execution/", method[i],"_map_bam_", meth.bam[j],".txt"), header =T)
    
    poscM <- (as.numeric(as.character(maps[,2]))/1000000)*cMByMb
    poscM.norm <- poscM-poscM[1]
    maps <- cbind(maps, poscM, poscM.norm)
    
    # Difference between distances real and estimated
    diff.dis <- sqrt((maps$poscM.norm - maps$rf)^2)
    df.diff.dis.bam[[i]][[j]] <- diff.dis
    names(df.diff.dis.bam[[i]][[j]]) <- paste0(method[i],"_",meth.bam[j])
    
    # Meth names
    names.id <-  c(names.id,paste0(method[i],"_",meth.bam[j]))
    
    # Mean of differences
    diff.dis.mean.bam <- mean(sqrt((maps$poscM.norm - maps$rf)^2))
    df.diff.mean.bam <- c(df.diff.mean.bam,diff.dis.mean.bam)
    
    # Median of differences
    diff.dis.median.bam <- median(sqrt((maps$poscM.norm - maps$rf)^2))
    df.diff.median.bam <- c(df.diff.median.bam,diff.dis.median.bam)
    
    # Difference of total size
    diff.tot.dis <- sqrt((maps$poscM.norm[length(maps$poscM.norm)] - maps$rf[length(maps$rf)])^2)
    df.diff.tot.bam <- c(df.diff.tot.bam,diff.tot.dis)
    
    mapfile.pos <- cbind(mapfile, tot_mks[,2])
    
    # Percentage of the chromosome covered 
    coverage <- maps$pos[length(maps$pos)]*100/mapfile.pos[,4][length(mapfile.pos[,4])]
    df.coverage.bam <- c(df.coverage.bam,coverage)
    
    # Percentage of rigth genotyping
    per.geno <- read.table(paste0("call-all_maps/shard-",id[i],"/execution/",method[i],"_error_",meth.bam[j],".txt"), header =T)
    per.geno <- (sum(per.geno$gabGT == per.geno$methGT)/length(per.geno$methGT)*100)
    df.per.geno.bam <- c(df.per.geno.bam,per.geno)
  }              
}

```

## Depth

Aqui mostra a distribuição das contagens de cada alelo, teoricamente deveriam ter homozigotos para os dois pais e heterozigotos no meio, uma diagonal (mas parece que só esta simulando homozigotos, isso altera tudo em seguida).


```{r}
# Depths from bam
p.bam
```


```{r}
# Depths from softwares
p
```


##  Difference between distances real and estimated

As distâncias estimadas do mapa deveriam ser as mesmas das simuladas, quanto mais perto do 0 o valor, melhor. O primeiro número sempre vai ser 0 porque eu normalizei.

```{r}
df.melt.diff.dis <- data.frame(method = c(rep("gatk", length(unlist(df.diff.dis[[1]]))), 
                                          rep("freebayes", length(unlist(df.diff.dis[[2]])))), 
                               genoty = c(rep("df", length(df.diff.dis[[1]][[1]])),
                                          rep("GQ", length(df.diff.dis[[1]][[2]])), 
                                          rep("polyrad", length(df.diff.dis[[1]][[3]])), 
                                          rep("updog", length(df.diff.dis[[1]][[4]])),
                                          rep("supermassa", length(df.diff.dis[[1]][[5]])),
                                          rep("df", length(df.diff.dis[[2]][[1]])),
                                          rep("GQ", length(df.diff.dis[[2]][[2]])), 
                                          rep("polyrad", length(df.diff.dis[[2]][[3]])), 
                                          rep("updog", length(df.diff.dis[[2]][[4]])),
                                          rep("supermassa", length(df.diff.dis[[2]][[5]]))),
                               value = unlist(df.diff.dis))


p<-ggplot(df.melt.diff.dis, aes(x=genoty, y=value, fill=method)) +
  geom_boxplot() + geom_hline(yintercept=0, color="red")
p
```

* Counts from bam

```{r}
df.melt.diff.dis.bam <- data.frame(method = c(rep("gatk", length(unlist(df.diff.dis.bam[[1]]))), 
                                          rep("freebayes", length(unlist(df.diff.dis.bam[[2]])))), 
                               genoty = c(rep("polyrad", length(df.diff.dis.bam[[1]][[1]])), 
                                          rep("updog", length(df.diff.dis.bam[[1]][[2]])),
                                          rep("supermassa", length(df.diff.dis.bam[[1]][[3]])),
                                          rep("polyrad", length(df.diff.dis.bam[[2]][[1]])), 
                                          rep("updog", length(df.diff.dis.bam[[2]][[2]])),
                                          rep("supermassa", length(df.diff.dis.bam[[2]][[3]]))),
                               value = unlist(df.diff.dis.bam))


p<-ggplot(df.melt.diff.dis.bam, aes(x=genoty, y=value, fill=method)) +
  geom_boxplot() + geom_hline(yintercept=0, color="red")
p

```


## Difference of total size

Como serão várias famílias, vai ficar difícil comparar em relação à todas as marcas, então estou considerando comparar só o tamanho total, média e mediana de cada família. Quando tiver várias famílias, mudar de barplot para boxplot.

```{r}

df.diff.tot1 <- data.frame("snp.call" = c(rep("gatk", 5), rep("freebayes", 5)), "genotype.prob" = rep(c("df","GQ", "polyrad", "updog", "supermassa"), 2), "value" = df.diff.tot)

p <- ggplot(data=df.diff.tot1, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p

```


```{r}
df.diff.tot1.bam <- data.frame("snp.call" = c(rep("gatk", 3), rep("freebayes", 3)), "genotype.prob" = rep(c("polyrad", "updog", "supermassa"), 2), "value" = df.diff.tot.bam)

p <- ggplot(data=df.diff.tot1.bam, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p

```


## Median of differences

```{r}

df.diff.median1 <- data.frame("snp.call" = c(rep("gatk", 5), rep("freebayes", 5)), "genotype.prob" = rep(c("df", "GQ", "polyrad", "updog", "supermassa"), 2), "value" = df.diff.median)

p <- ggplot(data=df.diff.median1, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p
```


```{r}

df.diff.median1.bam <- data.frame("snp.call" = c(rep("gatk", 3), rep("freebayes", 3)), "genotype.prob" = rep(c("polyrad", "updog", "supermassa"), 2), "value" = df.diff.median.bam)

p <- ggplot(data=df.diff.median1.bam, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p
```


## Mean of differences

```{r}

df.diff.mean1 <- data.frame("snp.call" = c(rep("gatk", 5), rep("freebayes", 5)), "genotype.prob" = rep(c("df", "GQ", "polyrad", "updog", "supermassa"), 2), "value" = df.diff.mean)

p <- ggplot(data=df.diff.mean1, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p

```


```{r}

df.diff.mean1.bam <- data.frame("snp.call" = c(rep("gatk", 3), rep("freebayes", 3)), "genotype.prob" = rep(c("polyrad", "updog", "supermassa"), 2), "value" = df.diff.mean.bam)

p <- ggplot(data=df.diff.mean1.bam, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p

```


## Percentage of rigth genotyping

Comparação entre os genótipos simulados e estimados com cada método

```{r}

df.per.geno1 <- data.frame("snp.call" = c(rep("gatk", 4), rep("freebayes", 4)), "genotype.prob" = rep(c("GQ", "polyrad", "updog", "supermassa"), 2), "value" = df.per.geno)

p <- ggplot(data=df.per.geno1, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p

```


```{r}

df.per.geno1.bam <- data.frame("snp.call" = c(rep("gatk", 3), rep("freebayes", 3)), "genotype.prob" = rep(c("polyrad", "updog", "supermassa"), 2), "value" = df.per.geno.bam)

p <- ggplot(data=df.per.geno1.bam, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p

```


## Percentage of the chromosome covered 


```{r}

df.coverage1 <- data.frame("snp.call" = c(rep("gatk", 5), rep("freebayes", 5)), "genotype.prob" = rep(c("df", "GQ", "polyrad", "updog", "supermassa"), 2), "value" = df.coverage)

p <- ggplot(data=df.coverage1, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p

```


```{r}

df.coverage1.bam <- data.frame("snp.call" = c(rep("gatk", 3), rep("freebayes", 3)), "genotype.prob" = rep(c("polyrad", "updog", "supermassa"), 2), "value" = df.coverage.bam)

p <- ggplot(data=df.coverage1.bam, aes(x=genotype.prob, y=value, fill=snp.call)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p

```


## Number of filtered

```{r}
df.filt2 <- cbind(c("gatk", "freebayes"),df.filt)
colnames(df.filt2) <- c("method", "n.snps.simu", "n.snps.identified", "n.snps.okay", "n.snps.fake", "n.snps.ref.okay", "n.snps.alt.okay")

df.filt2.melt <- melt(df.filt2)

p <- ggplot(data=df.filt2.melt, aes(x=variable, y=value, fill=method)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal()
p
```


```
Só para lembrar:
Acho que rola fazer uma discussão sobre numero de indivíduos e resolução do mapa, com poucos individuos o mapa fica inflado tb

Rola fazer outra discussão sobre a cobertura que o RADseq cobre , a capacidade dos softwares de identificar no genoma inteiro - Se o tamanho total do mapa nao corresponder ao cromossomo inteiro pode ser que ele esteja inflado e as pessoas pensem que ele esta no tamanho certo
``` 
